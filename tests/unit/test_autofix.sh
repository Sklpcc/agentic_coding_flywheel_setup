#!/usr/bin/env bash
# ============================================================
# Unit tests for scripts/lib/autofix.sh
#
# Run with: bash tests/unit/test_autofix.sh
# ============================================================

# Note: We use set -u but NOT set -e because:
# 1. ((var++)) returns 1 when var=0 which would exit with set -e
# 2. We want to continue running tests even if some fail
set -uo pipefail

# Get the absolute path to the scripts directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Source the autofix library
source "$REPO_ROOT/scripts/lib/autofix.sh"

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

# ============================================================
# Test Helpers
# ============================================================

test_pass() {
    TESTS_PASSED=$((TESTS_PASSED + 1))
    echo "PASS: $1"
}

test_fail() {
    TESTS_FAILED=$((TESTS_FAILED + 1))
    echo "FAIL: $1"
}

run_test() {
    local test_name="$1"
    TESTS_RUN=$((TESTS_RUN + 1))
    echo "Running: $test_name..."
    if "$test_name"; then
        test_pass "$test_name"
    else
        test_fail "$test_name"
    fi
}

# Setup test environment
setup_test_env() {
    # Use unique directory for each test to avoid interference
    local test_id="${FUNCNAME[1]:-$$}_$(date +%s%N)"
    export ACFS_STATE_DIR="/tmp/test_autofix_${test_id}"
    export ACFS_CHANGES_FILE="$ACFS_STATE_DIR/changes.jsonl"
    export ACFS_UNDOS_FILE="$ACFS_STATE_DIR/undos.jsonl"
    export ACFS_BACKUPS_DIR="$ACFS_STATE_DIR/backups"
    export ACFS_LOCK_FILE="$ACFS_STATE_DIR/.lock"
    export ACFS_INTEGRITY_FILE="$ACFS_STATE_DIR/.integrity"

    # Reset in-memory state
    ACFS_CHANGE_RECORDS=()
    ACFS_CHANGE_ORDER=()
    ACFS_AUTOFIX_INITIALIZED=false

    # Clean start
    rm -rf "$ACFS_STATE_DIR"
    mkdir -p "$ACFS_STATE_DIR"
    mkdir -p "$ACFS_BACKUPS_DIR"

    # Create empty files
    : > "$ACFS_CHANGES_FILE"
    : > "$ACFS_UNDOS_FILE"
}

# Cleanup test environment
cleanup_test_env() {
    rm -rf "/tmp/test_autofix_"* 2>/dev/null || true
    rm -rf "/tmp/test_atomic_"* 2>/dev/null || true
    rm -rf "/tmp/test_backup_"* 2>/dev/null || true
    rm -rf "/tmp/test_fsync_"* 2>/dev/null || true
    rm -rf "/tmp/test_undo_"* 2>/dev/null || true
}

# ============================================================
# Test Functions
# ============================================================

# Test: Atomic write
test_atomic_write() {
    local test_file="/tmp/test_atomic_$$"
    local content="test content $(date +%s)"

    write_atomic "$test_file" "$content"

    if [[ ! -f "$test_file" ]]; then
        echo "  File not created"
        rm -f "$test_file"
        return 1
    fi

    local actual_content
    actual_content=$(cat "$test_file")
    if [[ "$actual_content" != "$content" ]]; then
        echo "  Content mismatch: expected '$content', got '$actual_content'"
        rm -f "$test_file"
        return 1
    fi

    rm -f "$test_file"
    return 0
}

# Test: Atomic append
test_atomic_append() {
    local test_file="/tmp/test_atomic_append_$$"

    # First write
    write_atomic "$test_file" "line1"

    # Append
    append_atomic "$test_file" "line2"
    append_atomic "$test_file" "line3"

    local line_count
    line_count=$(wc -l < "$test_file")
    if [[ "$line_count" -ne 3 ]]; then
        echo "  Expected 3 lines, got $line_count"
        rm -f "$test_file"
        return 1
    fi

    local last_line
    last_line=$(tail -1 "$test_file")
    if [[ "$last_line" != "line3" ]]; then
        echo "  Last line mismatch: expected 'line3', got '$last_line'"
        rm -f "$test_file"
        return 1
    fi

    rm -f "$test_file"
    return 0
}

# Test: Backup creation with checksum
test_backup_creation() {
    setup_test_env

    local test_file="/tmp/test_backup_orig_$$"
    echo "original content" > "$test_file"

    ACFS_SESSION_ID="test_sess"

    local backup_json
    backup_json=$(create_backup "$test_file" "test")

    if [[ -z "$backup_json" ]]; then
        echo "  No backup JSON returned"
        rm -f "$test_file"
        cleanup_test_env
        return 1
    fi

    local backup_path
    backup_path=$(echo "$backup_json" | jq -r '.backup')
    if [[ ! -f "$backup_path" ]]; then
        echo "  Backup file not created: $backup_path"
        rm -f "$test_file"
        cleanup_test_env
        return 1
    fi

    # Verify checksum
    if ! verify_backup_integrity "$backup_json"; then
        echo "  Integrity check failed"
        rm -f "$test_file"
        cleanup_test_env
        return 1
    fi

    rm -f "$test_file"
    cleanup_test_env
    return 0
}

# Test: Backup of non-existent file
test_backup_nonexistent_file() {
    setup_test_env
    ACFS_SESSION_ID="test_sess"

    local backup_json
    backup_json=$(create_backup "/tmp/this_file_does_not_exist_$$" "test")

    if [[ -n "$backup_json" ]]; then
        echo "  Expected empty result for non-existent file"
        cleanup_test_env
        return 1
    fi

    cleanup_test_env
    return 0
}

# Test: Record checksum computation
test_record_checksum() {
    local record='{"id":"chg_001","description":"test"}'

    local checksum1 checksum2
    checksum1=$(compute_record_checksum "$record")
    checksum2=$(compute_record_checksum "$record")

    if [[ "$checksum1" != "$checksum2" ]]; then
        echo "  Checksums not deterministic: $checksum1 vs $checksum2"
        return 1
    fi

    if [[ ${#checksum1} -ne 64 ]]; then
        echo "  Invalid checksum length: ${#checksum1} (expected 64)"
        return 1
    fi

    # Different content should have different checksum
    local record2='{"id":"chg_002","description":"test"}'
    local checksum3
    checksum3=$(compute_record_checksum "$record2")

    if [[ "$checksum1" == "$checksum3" ]]; then
        echo "  Different records have same checksum"
        return 1
    fi

    return 0
}

# Test: State integrity verification
test_state_integrity() {
    setup_test_env

    # Create valid records
    echo '{"id":"chg_001","description":"test1"}' > "$ACFS_CHANGES_FILE"
    echo '{"id":"chg_002","description":"test2"}' >> "$ACFS_CHANGES_FILE"

    if ! verify_state_integrity 2>/dev/null; then
        echo "  Valid state rejected"
        cleanup_test_env
        return 1
    fi

    # Add invalid JSON
    echo 'not valid json' >> "$ACFS_CHANGES_FILE"

    if verify_state_integrity 2>/dev/null; then
        echo "  Invalid state accepted"
        cleanup_test_env
        return 1
    fi

    cleanup_test_env
    return 0
}

# Test: State repair
test_state_repair() {
    setup_test_env

    # Create file with mix of valid and invalid lines
    echo '{"id":"chg_001","description":"test1"}' > "$ACFS_CHANGES_FILE"
    echo 'invalid json line' >> "$ACFS_CHANGES_FILE"
    echo '{"id":"chg_002","description":"test2"}' >> "$ACFS_CHANGES_FILE"

    # Repair should succeed
    repair_state_files 2>/dev/null

    # Now verification should pass
    if ! verify_state_integrity 2>/dev/null; then
        echo "  State repair did not fix issues"
        cleanup_test_env
        return 1
    fi

    # Should have exactly 2 lines
    local line_count
    line_count=$(wc -l < "$ACFS_CHANGES_FILE")
    if [[ "$line_count" -ne 2 ]]; then
        echo "  Expected 2 lines after repair, got $line_count"
        cleanup_test_env
        return 1
    fi

    cleanup_test_env
    return 0
}

# Test: Session management
test_session_management() {
    setup_test_env

    if ! start_autofix_session 2>/dev/null; then
        echo "  Failed to start session"
        cleanup_test_env
        return 1
    fi

    if [[ -z "$ACFS_SESSION_ID" ]]; then
        echo "  Session ID not set"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    if [[ ! -f "$ACFS_STATE_DIR/.session" ]]; then
        echo "  Session marker not created"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    end_autofix_session 2>/dev/null || true

    if [[ -f "$ACFS_STATE_DIR/.session" ]]; then
        echo "  Session marker not removed"
        cleanup_test_env
        return 1
    fi

    cleanup_test_env
    return 0
}

# Test: Record change and list
test_record_change() {
    setup_test_env

    if ! start_autofix_session 2>/dev/null; then
        echo "  Failed to start session"
        cleanup_test_env
        return 1
    fi

    local change_id
    change_id=$(record_change "test" "Test change" "echo undo" "false" "info" '[]' '[]' '[]' 2>/dev/null)

    if [[ -z "$change_id" ]]; then
        echo "  Failed to record change"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    if [[ ! "$change_id" =~ ^chg_ ]]; then
        echo "  Invalid change ID format: $change_id"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    # Verify persisted (note: in-memory state is lost due to subshell from command substitution)
    if [[ ! -s "$ACFS_CHANGES_FILE" ]]; then
        echo "  Changes file is empty"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    # Verify the persisted change has the correct ID
    local persisted_id
    persisted_id=$(jq -r '.id' "$ACFS_CHANGES_FILE" | tail -1)
    if [[ "$persisted_id" != "$change_id" ]]; then
        echo "  Persisted ID mismatch: expected '$change_id', got '$persisted_id'"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    end_autofix_session 2>/dev/null || true
    cleanup_test_env
    return 0
}

# Test: Multiple changes preserve order
test_multiple_changes_order() {
    setup_test_env

    if ! start_autofix_session 2>/dev/null; then
        echo "  Failed to start session"
        cleanup_test_env
        return 1
    fi

    local id1 id2 id3
    id1=$(record_change "cat1" "First" "echo 1" "false" "info" '[]' '[]' '[]' 2>/dev/null)
    id2=$(record_change "cat2" "Second" "echo 2" "false" "info" '[]' '[]' '[]' 2>/dev/null)
    id3=$(record_change "cat3" "Third" "echo 3" "false" "info" '[]' '[]' '[]' 2>/dev/null)

    # Check we got 3 changes in the file
    local file_count
    file_count=$(wc -l < "$ACFS_CHANGES_FILE")
    if [[ "$file_count" -ne 3 ]]; then
        echo "  Expected 3 changes in file, got $file_count"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    # Check order of IDs (should be sequential)
    if [[ "$id1" != "chg_0001" ]] || [[ "$id2" != "chg_0002" ]] || [[ "$id3" != "chg_0003" ]]; then
        echo "  Change IDs not sequential: $id1, $id2, $id3"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    # Check order in file
    local first_id last_id
    first_id=$(head -1 "$ACFS_CHANGES_FILE" | jq -r '.id')
    last_id=$(tail -1 "$ACFS_CHANGES_FILE" | jq -r '.id')
    if [[ "$first_id" != "chg_0001" ]] || [[ "$last_id" != "chg_0003" ]]; then
        echo "  File order incorrect: first=$first_id, last=$last_id"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    end_autofix_session 2>/dev/null || true
    cleanup_test_env
    return 0
}

# Test: Undo command execution
test_undo_change() {
    setup_test_env

    if ! start_autofix_session 2>/dev/null; then
        echo "  Failed to start session"
        cleanup_test_env
        return 1
    fi

    # Create a test file that the undo command will remove
    local test_marker="/tmp/test_undo_marker_$$"
    touch "$test_marker"

    # Record a change that removes the marker
    local change_id
    change_id=$(record_change "test" "Test change" "rm -f '$test_marker'" "false" "info" '[]' '[]' '[]' 2>/dev/null)

    # Undo should remove the marker
    if ! undo_change "$change_id" true true 2>/dev/null; then
        echo "  Undo failed"
        rm -f "$test_marker"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    if [[ -f "$test_marker" ]]; then
        echo "  Undo command did not execute (marker still exists)"
        rm -f "$test_marker"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    end_autofix_session 2>/dev/null || true
    cleanup_test_env
    return 0
}

# Test: fsync_file function
test_fsync_file() {
    local test_file="/tmp/test_fsync_$$"
    echo "test" > "$test_file"

    # Should not error
    if ! fsync_file "$test_file"; then
        echo "  fsync_file failed"
        rm -f "$test_file"
        return 1
    fi

    rm -f "$test_file"
    return 0
}

# Test: fsync_directory function
test_fsync_directory() {
    local test_dir="/tmp/test_fsync_dir_$$"
    mkdir -p "$test_dir"

    # Should not error
    if ! fsync_directory "$test_dir"; then
        echo "  fsync_directory failed"
        rm -rf "$test_dir"
        return 1
    fi

    rm -rf "$test_dir"
    return 0
}

# Test: Init autofix state
test_init_autofix_state() {
    setup_test_env

    # Remove the directories we just created to test init
    rm -rf "$ACFS_STATE_DIR"

    if ! init_autofix_state 2>/dev/null; then
        echo "  init_autofix_state failed"
        cleanup_test_env
        return 1
    fi

    if [[ ! -d "$ACFS_STATE_DIR" ]]; then
        echo "  State directory not created"
        cleanup_test_env
        return 1
    fi

    if [[ ! -d "$ACFS_BACKUPS_DIR" ]]; then
        echo "  Backups directory not created"
        cleanup_test_env
        return 1
    fi

    cleanup_test_env
    return 0
}

# Test: Print undo summary (no errors)
test_print_undo_summary() {
    setup_test_env

    if ! start_autofix_session 2>/dev/null; then
        echo "  Failed to start session"
        cleanup_test_env
        return 1
    fi

    record_change "test" "Test change 1" "echo 1" "false" "info" '[]' '[]' '[]' >/dev/null 2>&1
    record_change "test" "Test change 2" "echo 2" "false" "info" '[]' '[]' '[]' >/dev/null 2>&1

    # Should not error
    if ! print_undo_summary >/dev/null 2>&1; then
        echo "  print_undo_summary failed"
        end_autofix_session 2>/dev/null || true
        cleanup_test_env
        return 1
    fi

    end_autofix_session 2>/dev/null || true
    cleanup_test_env
    return 0
}

# Test: Update integrity file
test_update_integrity_file() {
    setup_test_env

    echo '{"id":"chg_001"}' > "$ACFS_CHANGES_FILE"

    update_integrity_file 2>/dev/null

    if [[ ! -f "$ACFS_INTEGRITY_FILE" ]]; then
        echo "  Integrity file not created"
        cleanup_test_env
        return 1
    fi

    # Verify it's valid JSON
    if ! jq -e . "$ACFS_INTEGRITY_FILE" >/dev/null 2>&1; then
        echo "  Integrity file is not valid JSON"
        cleanup_test_env
        return 1
    fi

    cleanup_test_env
    return 0
}

# ============================================================
# Main Test Runner
# ============================================================

main() {
    echo "============================================================"
    echo "Running autofix unit tests..."
    echo "============================================================"
    echo ""

    run_test test_atomic_write
    run_test test_atomic_append
    run_test test_fsync_file
    run_test test_fsync_directory
    run_test test_backup_creation
    run_test test_backup_nonexistent_file
    run_test test_record_checksum
    run_test test_state_integrity
    run_test test_state_repair
    run_test test_init_autofix_state
    run_test test_session_management
    run_test test_record_change
    run_test test_multiple_changes_order
    run_test test_undo_change
    run_test test_print_undo_summary
    run_test test_update_integrity_file

    echo ""
    echo "============================================================"
    echo "Test Summary"
    echo "============================================================"
    echo "  Total:  $TESTS_RUN"
    echo "  Passed: $TESTS_PASSED"
    echo "  Failed: $TESTS_FAILED"
    echo "============================================================"

    if [[ $TESTS_FAILED -gt 0 ]]; then
        exit 1
    fi
    exit 0
}

main "$@"
